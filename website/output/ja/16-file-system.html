<!DOCTYPE html>
<html><head><title>ファイルシステム - 1000行で作るOS</title><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" href="/styles.css"><meta name="generator" content="Docship (https://github.com/nuta/docship)"></head><body class="mx-auto max-w-3xl w-full py-8 px-4"><header><h1 class="text-center mb-8 text-xl font-bold">1000行で作るOS - ファイルシステム</h1><div class="mb-8 container mx-auto flex justify-center"><ol class="w-full my-0 sm:w-fit grid grid-rows-[repeat(9,auto)] grid-flow-col gap-x-4" start="0"><li class="my-1"><a href="/ja/index" class="">はじめに</a></li><li class="my-1"><a href="/ja/01-setting-up-development-environment" class="">開発環境</a></li><li class="my-1"><a href="/ja/02-assembly" class="">RISC-V入門</a></li><li class="my-1"><a href="/ja/03-overview" class="">OSの全体像</a></li><li class="my-1"><a href="/ja/04-boot" class="">ブート</a></li><li class="my-1"><a href="/ja/05-hello-world" class="">Hello World!</a></li><li class="my-1"><a href="/ja/06-libc" class="">C標準ライブラリ</a></li><li class="my-1"><a href="/ja/07-kernel-panic" class="">カーネルパニック</a></li><li class="my-1"><a href="/ja/08-exception" class="">例外処理</a></li><li class="my-1"><a href="/ja/09-memory-allocation" class="">メモリ割り当て</a></li><li class="my-1"><a href="/ja/10-process" class="">プロセス</a></li><li class="my-1"><a href="/ja/11-page-table" class="">ページテーブル</a></li><li class="my-1"><a href="/ja/12-application" class="">アプリケーション</a></li><li class="my-1"><a href="/ja/13-user-mode" class="">ユーザーモード</a></li><li class="my-1"><a href="/ja/14-system-call" class="">システムコール</a></li><li class="my-1"><a href="/ja/15-virtio-blk" class="">ディスク読み書き</a></li><li class="my-1"><a href="/ja/16-file-system" class="font-bold">ファイルシステム</a></li><li class="my-1"><a href="/ja/17-conclusion" class="">おわりに</a></li></ol></div></header><main><p>ディスクの読み書きができるようになったので、ファイルの読み書きを実装しましょう。</p>
<h2 id="tarファイルシステム"><a class="anchor" href="#tarファイルシステム">tarファイルシステム</a></h2>
<p>本書では、ちょっぴり面白いアプローチでファイルシステムを実装します。それは「tarファイルをファイルシステムとして使う」というものです。</p>
<p>tarファイルは、複数のファイルをまとめるアーカイブファイルです。tarファイルの中には、ファイルの内容とファイル名、作成日時などファイルシステムとして必要な情報が含まれています。FATやext2などの一般的なファイルシステム形式に比べ非常に簡素なデータ構造であるのと、馴染み深いであろうtarコマンドを使ってファイルシステムイメージを操作できるので、教育用にはもってこいのファイル形式なのです。</p>
<h2 id="ディスクイメージの作成"><a class="anchor" href="#ディスクイメージの作成">ディスクイメージの作成</a></h2>
<p>まずはファイルシステムの内容を用意しましょう。<code>disk</code>ディレクトリを作成し、その中に適当なファイルを作成します。一つは<code>hello.txt</code>という名前にしておきます。</p>
<pre><code class="language-plain">$ mkdir disk
$ vim disk/hello.txt
$ vim disk/meow.txt
</code></pre>
<p>ビルドスクリプトにtarファイルの作成コマンドを追加し、それをディスクイメージとしてQEMUに渡すようにします。</p>
<pre><div class="code-block-title">run.sh</div><code class="language-bash">(cd disk <span class="pl-k">&#x26;&#x26;</span> tar cf ../disk.tar --format=ustar ./<span class="pl-k">*</span>.txt)

<span class="pl-smi">$QEMU</span> -machine virt -bios default -nographic -serial mon:stdio --no-reboot \
    -d unimp,guest_errors,int,cpu_reset -D qemu.log \
    -drive id=drive0,file=disk.tar,format=raw \
    -device virtio-blk-device,drive=drive0,bus=virtio-mmio-bus.0 \
    -kernel kernel.elf
</code></pre>
<p>ここで使われている<code>tar</code>コマンドのオプションは次のとおりです:</p>
<ul>
<li><code>cf</code>: tarファイルを作成する</li>
<li><code>--format=ustar</code>: ustar形式のtarファイルを作成する</li>
</ul>
<p>なお、tarコマンドの行が丸括弧 <code>(...)</code> で囲われているのは、囲われたコマンドを独立したシェルで実行する <strong>サブシェル</strong> という機能です。これを使うことで、<code>cd</code> コマンドでのディレクトリ移動が括弧外に影響しないようにできます。</p>
<h2 id="tarファイルの構造"><a class="anchor" href="#tarファイルの構造">tarファイルの構造</a></h2>
<p>tarファイルは、次のような構造をしています。</p>
<pre><code class="language-plain">+----------------+
|   tar ヘッダ    |
+----------------+
|  ファイルデータ  |
+----------------+
|   tar ヘッダ    |
+----------------+
|  ファイルデータ  |
+----------------+
|      ...       |
</code></pre>
<p>つまり、「tarヘッダ」と「ファイルデータ」のペアがファイルの数だけ続いたものがtarファイルです。tarにはいくつかの種類がありますが、本書では <strong>ustar形式</strong> (<a href="https://en.wikipedia.org/wiki/Tar_(computing)#UStar_format">Wikipedia</a>) を使います。</p>
<p>今回は、このファイル構造をそのままファイルシステムのデータ構造として利用します。</p>
<h2 id="ファイルシステムの読み込み"><a class="anchor" href="#ファイルシステムの読み込み">ファイルシステムの読み込み</a></h2>
<p>まずはファイルシステム関連のデータ構造を定義します。<code>kernel.h</code>に次のように定義します。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">FILES_MAX</span>      <span class="pl-c1">2</span>
#<span class="pl-k">define</span> <span class="pl-en">DISK_MAX_SIZE</span>  <span class="pl-en">align_up</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> file) * FILES_MAX, SECTOR_SIZE)

struct tar_header {
    <span class="pl-k">char</span> name[<span class="pl-c1">100</span>];
    <span class="pl-k">char</span> mode[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> uid[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> gid[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> size[<span class="pl-c1">12</span>];
    <span class="pl-k">char</span> mtime[<span class="pl-c1">12</span>];
    <span class="pl-k">char</span> checksum[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> type;
    <span class="pl-k">char</span> linkname[<span class="pl-c1">100</span>];
    <span class="pl-k">char</span> magic[<span class="pl-c1">6</span>];
    <span class="pl-k">char</span> version[<span class="pl-c1">2</span>];
    <span class="pl-k">char</span> uname[<span class="pl-c1">32</span>];
    <span class="pl-k">char</span> gname[<span class="pl-c1">32</span>];
    <span class="pl-k">char</span> devmajor[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> devminor[<span class="pl-c1">8</span>];
    <span class="pl-k">char</span> prefix[<span class="pl-c1">155</span>];
    <span class="pl-k">char</span> padding[<span class="pl-c1">12</span>];
    <span class="pl-k">char</span> data[];      <span class="pl-c">// ヘッダに続くデータ領域を指す配列 (フレキシブル配列メンバ)</span>
} __attribute__((packed));

<span class="pl-k">struct</span> file {
    <span class="pl-k">bool</span> in_use;      <span class="pl-c">// このファイルエントリが使われているか</span>
    <span class="pl-k">char</span> name[<span class="pl-c1">100</span>];   <span class="pl-c">// ファイル名</span>
    <span class="pl-k">char</span> data[<span class="pl-c1">1024</span>];  <span class="pl-c">// ファイルの内容</span>
    <span class="pl-c1">size_t</span> size;      <span class="pl-c">// ファイルサイズ</span>
};
</code></pre>
<p>本書のファイルシステム実装では、全てのファイルを起動時にディスクからメモリへ読み込みます。各ファイルのtarヘッダ (<code>struct tar_header</code>) と、それに続くファイルの内容を<code>file</code>構造体へ読み込みます。<code>FILES_MAX</code>が読み込む最大ファイル数、<code>DISK_MAX_SIZE</code>がディスクイメージの最大サイズです。</p>
<p>実際にファイルを読み込む処理が、次の<code>fs_init</code>関数です。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">struct</span> file files[FILES_MAX];
<span class="pl-c1">uint8_t</span> disk[DISK_MAX_SIZE];

<span class="pl-k">int</span> <span class="pl-en">oct2int</span>(<span class="pl-k">char</span> *oct, <span class="pl-k">int</span> len) {
    <span class="pl-k">int</span> dec = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &#x3C; len; i++) {
        <span class="pl-k">if</span> (oct[i] &#x3C; <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> || oct[i] > <span class="pl-s"><span class="pl-pds">'</span>7<span class="pl-pds">'</span></span>)
            <span class="pl-k">break</span>;

        dec = dec * <span class="pl-c1">8</span> + (oct[i] - <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>);
    }
    <span class="pl-k">return</span> dec;
}

<span class="pl-k">void</span> <span class="pl-en">fs_init</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">for</span> (<span class="pl-k">unsigned</span> sector = <span class="pl-c1">0</span>; sector &#x3C; <span class="pl-k">sizeof</span>(disk) / SECTOR_SIZE; sector++)
        <span class="pl-c1">read_write_disk</span>(&#x26;disk[sector * SECTOR_SIZE], sector, <span class="pl-c1">false</span>);

    <span class="pl-k">unsigned</span> off = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &#x3C; FILES_MAX; i++) {
        <span class="pl-k">struct</span> tar_header *header = (<span class="pl-k">struct</span> tar_header *) &#x26;disk[off];
        <span class="pl-k">if</span> (header-><span class="pl-smi">name</span>[<span class="pl-c1">0</span>] == <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>)
            <span class="pl-k">break</span>;

        <span class="pl-k">if</span> (<span class="pl-c1">strcmp</span>(header-><span class="pl-smi">magic</span>, <span class="pl-s"><span class="pl-pds">"</span>ustar<span class="pl-pds">"</span></span>) != <span class="pl-c1">0</span>)
            <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>invalid tar header: magic=<span class="pl-cce">\"</span><span class="pl-c1">%s</span><span class="pl-cce">\"</span><span class="pl-pds">"</span></span>, header-><span class="pl-smi">magic</span>);

        <span class="pl-k">int</span> filesz = <span class="pl-c1">oct2int</span>(header-><span class="pl-smi">size</span>, <span class="pl-k">sizeof</span>(header-><span class="pl-smi">size</span>));
        <span class="pl-k">struct</span> file *file = &#x26;files[i];
        file-><span class="pl-smi">in_use</span> = <span class="pl-c1">true</span>;
        <span class="pl-c1">strcpy</span>(file-><span class="pl-smi">name</span>, header-><span class="pl-smi">name</span>);
        <span class="pl-c1">memcpy</span>(file-><span class="pl-smi">data</span>, header-><span class="pl-smi">data</span>, filesz);
        file-><span class="pl-smi">size</span> = filesz;
        <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>file: <span class="pl-c1">%s</span>, size=<span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, file-><span class="pl-smi">name</span>, file-><span class="pl-smi">size</span>);

        off += <span class="pl-c1">align_up</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> tar_header) + filesz, SECTOR_SIZE);
    }
}
</code></pre>
<p>この関数では、まず<code>read_write_disk</code>関数を使ってディスクイメージをメモリ上 (<code>disk</code>変数) に読み込みます。<code>disk</code>変数はローカル変数 (スタック上) ではなく、わざと静的変数 (<code>static</code>) として宣言しています。スタックの大きさには限りがあるので、このようなデータ領域はなるべくスタックの利用を避けることが望ましいです。</p>
<p>ディスクの内容を読み込んだあとは、それをtarファイルと同じように順番に<code>files</code>変数のエントリとしてコピーしていきます。注意点として <strong>tarヘッダの数値は8進数表記</strong> です。<code>oct2int</code>関数で、8進数表記の文字列を整数に変換しています。</p>
<p>最後に、<code>fs_init</code>関数を<code>kernel_main</code>関数から呼び出すようにして完了です。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">kernel_main</span>(<span class="pl-k">void</span>) {
    <span class="pl-c1">memset</span>(__bss, <span class="pl-c1">0</span>, (<span class="pl-c1">size_t</span>) __bss_end - (<span class="pl-c1">size_t</span>) __bss);
    <span class="pl-c1">WRITE_CSR</span>(stvec, (<span class="pl-c1">uint32_t</span>) kernel_entry);
    <span class="pl-c1">virtio_blk_init</span>();
    <span class="pl-c1">fs_init</span>();

    <span class="pl-c">/* 省略 */</span>
}
</code></pre>
<h2 id="ファイルシステムの読み込みテスト"><a class="anchor" href="#ファイルシステムの読み込みテスト">ファイルシステムの読み込みテスト</a></h2>
<p>実際に動かしてみましょう。<code>disk</code>ディレクトリに用意したファイル名とその大きさが表示されれば成功です。</p>
<pre><code class="language-plain">$ ./run.sh

virtio-blk: capacity is 2560 bytes
file: world.txt, size=0
file: hello.txt, size=22
</code></pre>
<h2 id="ディスクへの書き込み戻し"><a class="anchor" href="#ディスクへの書き込み戻し">ディスクへの書き込み戻し</a></h2>
<p>ファイルシステムを読み込めるようになったので、次はファイルの書き込みを実装しましょう。ファイルの書き込みは、<code>files</code>変数の内容を、tarファイルの形式でディスクに書き込むことで実現します。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">fs_flush</span>(<span class="pl-k">void</span>) {
    <span class="pl-c">// files変数の各ファイルの内容をdisk変数に書き込む</span>
    <span class="pl-c1">memset</span>(disk, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(disk));
    <span class="pl-k">unsigned</span> off = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> file_i = <span class="pl-c1">0</span>; file_i &#x3C; FILES_MAX; file_i++) {
        <span class="pl-k">struct</span> file *file = &#x26;files[file_i];
        <span class="pl-k">if</span> (!file-><span class="pl-smi">in_use</span>)
            <span class="pl-k">continue</span>;

        <span class="pl-k">struct</span> tar_header *header = (<span class="pl-k">struct</span> tar_header *) &#x26;disk[off];
        <span class="pl-c1">memset</span>(header, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(*header));
        <span class="pl-c1">strcpy</span>(header-><span class="pl-smi">name</span>, file-><span class="pl-smi">name</span>);
        <span class="pl-c1">strcpy</span>(header-><span class="pl-smi">mode</span>, <span class="pl-s"><span class="pl-pds">"</span>000644<span class="pl-pds">"</span></span>);
        <span class="pl-c1">strcpy</span>(header-><span class="pl-smi">magic</span>, <span class="pl-s"><span class="pl-pds">"</span>ustar<span class="pl-pds">"</span></span>);
        <span class="pl-c1">strcpy</span>(header-><span class="pl-smi">version</span>, <span class="pl-s"><span class="pl-pds">"</span>00<span class="pl-pds">"</span></span>);
        header-><span class="pl-smi">type</span> = <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>;

        <span class="pl-c">// ファイルサイズを8進数文字列に変換</span>
        <span class="pl-k">int</span> filesz = file-><span class="pl-smi">size</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-k">sizeof</span>(header-><span class="pl-smi">size</span>); i > <span class="pl-c1">0</span>; i--) {
            header-><span class="pl-smi">size</span>[i - <span class="pl-c1">1</span>] = (filesz % <span class="pl-c1">8</span>) + <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>;
            filesz /= <span class="pl-c1">8</span>;
        }

        <span class="pl-c">// チェックサムを計算</span>
        <span class="pl-k">int</span> checksum = <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> * <span class="pl-k">sizeof</span>(header-><span class="pl-smi">checksum</span>);
        <span class="pl-k">for</span> (<span class="pl-k">unsigned</span> i = <span class="pl-c1">0</span>; i &#x3C; <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> tar_header); i++)
            checksum += (<span class="pl-k">unsigned</span> <span class="pl-k">char</span>) disk[off + i];

        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">5</span>; i >= <span class="pl-c1">0</span>; i--) {
            header-><span class="pl-smi">checksum</span>[i] = (checksum % <span class="pl-c1">8</span>) + <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>;
            checksum /= <span class="pl-c1">8</span>;
        }

        <span class="pl-c">// ファイルデータをコピー</span>
        <span class="pl-c1">memcpy</span>(header-><span class="pl-smi">data</span>, file-><span class="pl-smi">data</span>, file-><span class="pl-smi">size</span>);
        off += <span class="pl-c1">align_up</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> tar_header) + file-><span class="pl-smi">size</span>, SECTOR_SIZE);
    }

    <span class="pl-c">// disk変数の内容をディスクに書き込む</span>
    <span class="pl-k">for</span> (<span class="pl-k">unsigned</span> sector = <span class="pl-c1">0</span>; sector &#x3C; <span class="pl-k">sizeof</span>(disk) / SECTOR_SIZE; sector++)
        <span class="pl-c1">read_write_disk</span>(&#x26;disk[sector * SECTOR_SIZE], sector, <span class="pl-c1">true</span>);

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>wrote <span class="pl-c1">%d</span> bytes to disk<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-k">sizeof</span>(disk));
}
</code></pre>
<p>この関数では、まず<code>files</code>変数の内容をtarファイル形式で<code>disk</code>変数に書き込み、その後<code>disk</code>変数の内容をディスクに書き込みます。tarヘッダの各フィールドの値は8進数の文字列であるため、<code>strcpy</code>関数など文字列を扱う処理がみられます。</p>
<h2 id="ファイルの読み書きapi"><a class="anchor" href="#ファイルの読み書きapi">ファイルの読み書きAPI</a></h2>
<p>ファイルシステムの読み書きを実装したところで、アプリケーションからファイルの読み書きを行えるようにしましょう。本書ではファイルの読み込みを行う<code>readfile</code>、ファイルの書き込みを行う<code>writefile</code>というシステムコールを用意します。どちらもファイル名、読み書きに使うメモリバッファ、そしてバッファのサイズを引数に取ります。</p>
<pre><div class="code-block-title">common.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">SYS_READFILE</span>  <span class="pl-c1">4</span>
#<span class="pl-k">define</span> <span class="pl-en">SYS_WRITEFILE</span> <span class="pl-c1">5</span>
</code></pre>
<pre><div class="code-block-title">user.c</div><code class="language-c"><span class="pl-k">int</span> <span class="pl-en">readfile</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *filename, <span class="pl-k">char</span> *buf, <span class="pl-k">int</span> len) {
    <span class="pl-k">return</span> <span class="pl-bu">syscall</span>(SYS_READFILE, (<span class="pl-k">int</span>) filename, (<span class="pl-k">int</span>) buf, len);
}

<span class="pl-k">int</span> <span class="pl-en">writefile</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *filename, <span class="pl-k">const</span> <span class="pl-k">char</span> *buf, <span class="pl-k">int</span> len) {
    <span class="pl-k">return</span> <span class="pl-bu">syscall</span>(SYS_WRITEFILE, (<span class="pl-k">int</span>) filename, (<span class="pl-k">int</span>) buf, len);
}
</code></pre>
<pre><div class="code-block-title">user.h</div><code class="language-c"><span class="pl-k">int</span> <span class="pl-en">readfile</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *filename, <span class="pl-k">char</span> *buf, <span class="pl-k">int</span> len);
<span class="pl-k">int</span> <span class="pl-en">writefile</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *filename, <span class="pl-k">const</span> <span class="pl-k">char</span> *buf, <span class="pl-k">int</span> len);
</code></pre>
<blockquote class="callout callout-tip">
<p>一般的なOSのシステムコールの設計を読んでみて、何が省略されているのかを比較すると面白いでしょう。</p>
</blockquote>
<h2 id="システムコールの実装"><a class="anchor" href="#システムコールの実装">システムコールの実装</a></h2>
<p>前節で定義したシステムコールを実装しましょう。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">struct</span> file *<span class="pl-en">fs_lookup</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *filename) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &#x3C; FILES_MAX; i++) {
        <span class="pl-k">struct</span> file *file = &#x26;files[i];
        <span class="pl-k">if</span> (!<span class="pl-c1">strcmp</span>(file-><span class="pl-smi">name</span>, filename))
            <span class="pl-k">return</span> file;
    }

    <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
}

<span class="pl-k">void</span> <span class="pl-en">handle_syscall</span>(<span class="pl-k">struct</span> trap_frame *f) {
    <span class="pl-k">switch</span> (f-><span class="pl-smi">a3</span>) {
        <span class="pl-c">/* 省略 */</span>
        <span class="pl-k">case</span> SYS_READFILE:
        <span class="pl-k">case</span> SYS_WRITEFILE: {
            <span class="pl-k">const</span> <span class="pl-k">char</span> *filename = (<span class="pl-k">const</span> <span class="pl-k">char</span> *) f-><span class="pl-smi">a0</span>;
            <span class="pl-k">char</span> *buf = (<span class="pl-k">char</span> *) f-><span class="pl-smi">a1</span>;
            <span class="pl-k">int</span> len = f-><span class="pl-smi">a2</span>;
            <span class="pl-k">struct</span> file *file = <span class="pl-c1">fs_lookup</span>(filename);
            <span class="pl-k">if</span> (!file) {
                <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>file not found: <span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, filename);
                f-><span class="pl-smi">a0</span> = -<span class="pl-c1">1</span>;
                <span class="pl-k">break</span>;
            }

            <span class="pl-k">if</span> (len > (<span class="pl-k">int</span>) <span class="pl-k">sizeof</span>(file-><span class="pl-smi">data</span>))
                len = file-><span class="pl-smi">size</span>;

            <span class="pl-k">if</span> (f-><span class="pl-smi">a3</span> == SYS_WRITEFILE) {
                <span class="pl-c1">memcpy</span>(file-><span class="pl-smi">data</span>, buf, len);
                file-><span class="pl-smi">size</span> = len;
                <span class="pl-c1">fs_flush</span>();
            } <span class="pl-k">else</span> {
                <span class="pl-c1">memcpy</span>(buf, file-><span class="pl-smi">data</span>, len);
            }

            f-><span class="pl-smi">a0</span> = len;
            <span class="pl-k">break</span>;
        }
        <span class="pl-k">default</span>:
            <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>unexpected syscall a3=<span class="pl-c1">%x</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, f-><span class="pl-smi">a3</span>);
    }
}
</code></pre>
<p>ファイルの読み書き処理は共通する処理が多いので、同じところにまとめています。<code>fs_lookup</code>関数でファイル名から<code>files</code>変数のエントリを探し出し、読み込みであれば、ファイルエントリからデータを読み込み、書き込みであればファイルエントリの内容を書き換え、最後に<code>fs_flush</code>関数でディスクに書き込みます。</p>
<blockquote class="callout callout-warning">
<p>簡単のため、アプリケーションから渡されたポインタ (ユーザーポインタ) をそのまま参照していますが、これはセキュリティ上の問題があります。ユーザーが任意のメモリ領域を指定できてしまうと、システムコール経由でカーネルのメモリ領域を読み書きできてしまいます。</p>
</blockquote>
<h2 id="ファイルの読み書きコマンド"><a class="anchor" href="#ファイルの読み書きコマンド">ファイルの読み書きコマンド</a></h2>
<p>システムコールを実装したところで、シェルからファイルの読み書きを試してみましょう。シェルはコマンドライン引数のパースを実装していないので、とりあえず<code>hello.txt</code>を決めうちで読み書きする<code>readfile</code>と<code>writefile</code>コマンドを実装します。</p>
<pre><div class="code-block-title">shell.c</div><code class="language-c">        <span class="pl-k">else</span> <span class="pl-k">if</span> (strcmp(cmdline, <span class="pl-s"><span class="pl-pds">"</span>readfile<span class="pl-pds">"</span></span>) == <span class="pl-c1">0</span>) {
            <span class="pl-k">char</span> buf[<span class="pl-c1">128</span>];
            <span class="pl-k">int</span> len = <span class="pl-c1">readfile</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, buf, <span class="pl-k">sizeof</span>(buf));
            buf[len] = <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
            <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, buf);
        }
        <span class="pl-k">else</span> <span class="pl-k">if</span> (strcmp(cmdline, <span class="pl-s"><span class="pl-pds">"</span>writefile<span class="pl-pds">"</span></span>) == <span class="pl-c1">0</span>)
            <span class="pl-en">writefile</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Hello from shell!<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">19</span>);
</code></pre>
<p>実行してみると、次のようにページフォルトが発生してしまいます。</p>
<pre><code class="language-plain">$ ./run.sh

> readfile
PANIC: kernel.c:561: unexpected trap scause=0000000d, stval=01000423, sepc=8020128a
</code></pre>
<p><code>sepc</code>の値を<code>llvm-addr2line</code>で見てみると、<code>strcmp</code>関数でページフォルトが発生していることがわかります。</p>
<pre><code class="language-plain">$ llvm-objdump -d kernel.elf
...

80201282 &#x3C;strcmp>:
80201282: 03 46 05 00   lbu     a2, 0(a0)
80201286: 15 c2         beqz    a2, 0x802012aa &#x3C;.LBB3_4>
80201288: 05 05         addi    a0, a0, 1

8020128a &#x3C;.LBB3_2>:
8020128a: 83 c6 05 00   lbu     a3, 0(a1) ← ここでページフォルト: a1は第2引数
8020128e: 33 37 d0 00   snez    a4, a3
80201292: 93 77 f6 0f   andi    a5, a2, 255
80201296: bd 8e         xor     a3, a3, a5
80201298: 93 b6 16 00   seqz    a3, a3
</code></pre>
<p>ページテーブルの内容を確認してみると、<code>0x1000423</code>のページ (<code>vaddr = 01000000</code>) は確かに読み・書き・実行可能 (<code>rwx</code>) なユーザーページ (<code>u</code>) としてマップされています。</p>
<pre><code class="language-plain">QEMU 8.0.2 monitor - type 'help' for more information
(qemu) info mem
vaddr    paddr            size     attr
-------- ---------------- -------- -------
01000000 000000008026c000 00001000 rwxu-a-
</code></pre>
<p>試しに仮想アドレスでメモリダンプ (<code>x</code>コマンド) をしてみましょう。</p>
<pre><code class="language-plain">(qemu) x /10c 0x1000423
01000423: 'h' 'e' 'l' 'l' 'o' '.' 't' 'x' 't' '\x00' 'r' 'e' 'a' 'd' 'f' 'i'
01000433: 'l' 'e' '\x00' 'h' 'e' 'l' 'l' 'o' '\x00' '%' 's' '\n' '\x00' 'e' 'x' 'i'
01000443: 't' '\x00' 'w' 'r' 'i' 't' 'e' 'f'
</code></pre>
<p>ページテーブルの設定が正しくない場合、<code>x</code>コマンドはエラーを表示します。ここでは、ページテーブルが正しく設定されており、ポインタは確かに<code>hello.txt</code>の文字列を指していることがわかります。</p>
<p>答えを言ってしまうと「<code>sstatus</code>レジスタの<code>SUM</code>ビットがセットされていない」ことが原因です。</p>
<h2 id="ユーザーポインタへのアクセス"><a class="anchor" href="#ユーザーポインタへのアクセス">ユーザーポインタへのアクセス</a></h2>
<p>RISC-Vでは、<code>sstatus</code>レジスタによってS-Mode (カーネル) の振る舞いを変更できます。その中の一つが <strong>SUM (permit Supervisor User Memory access) ビット</strong> です。これがセットされていない場合、S-Modeのプログラム (カーネル) はU-Mode (ユーザー) のページにアクセスできません。</p>
<blockquote class="callout callout-tip">
<p>意図せずユーザーのメモリ領域を参照しないようにする、一種の安全策です。
ちなみにIntelのCPUにも「SMAP (Supervisor Mode Access Prevention)」という名前で実装されています。</p>
</blockquote>
<p><code>SUM</code>ビットの位置を次のように定義します。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">SSTATUS_SUM</span>  (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">18</span>)
</code></pre>
<p>あとはユーザー空間に入る時に<code>sstatus</code>レジスタにセットすれば修正完了です。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-en">__attribute__</span>((naked)) void user_entry(<span class="pl-k">void</span>) {
    <span class="pl-k">__asm__</span> <span class="pl-smi">__volatile__</span>(
        <span class="pl-s"><span class="pl-pds">"</span>csrw sepc, %[sepc]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw sstatus, %[sstatus]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>sret<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        :
        : [sepc] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (USER_BASE),
          [sstatus] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (SSTATUS_SPIE | SSTATUS_SUM)
    );
}
</code></pre>
<blockquote class="callout callout-tip">
<p>ここでは「SUMビットが原因」とさらっと説明していますが「自分でこれを見つけられるか？」というのは難しい問題です。ページフォルトが起きていることは分かっても、その具体的な原因は分からないことがほとんどです。CPUは困ったことに細かいエラーコードすら出してくれないのです。筆者がなぜ気づいたかというと「SUMビットを知っていたから」です。</p>
<p>このような「上手く動かない」場合のデバッグ方法は次のようなものがあります。</p>
<ul>
<li>RISC-Vの仕様書をよく読む。「SUMビットが立っていると、S-ModeでもU-Mode用ページにアクセスできる」と一応書いてある。</li>
<li>QEMU本体の実装を読む。前述のページフォルトの原因は<a href="https://github.com/qemu/qemu/blob/d1181d29370a4318a9f11ea92065bea6bb159f83/target/riscv/cpu_helper.c#L1008">ココで実装されている</a>。ただし仕様書をよく読むのと同等かそれ以上に大変。</li>
<li>ChatGPTとかに上手く聞き出す (<a href="https://sdk.vercel.ai/r/H0gm2Ky">成功例</a>)。</li>
</ul>
<p>これが「ゼロからOSを作る」のが時間泥棒で挫折しやすい大きな理由のひとつです。ただ、辛い分だけ解決した時の達成感は他のソフトウェア開発では味わえないものがあります。辛い思いをするのがゼロからのOS自作の醍醐味とも言えるでしょう。</p>
</blockquote>
<h2 id="ファイルの読み書きテスト"><a class="anchor" href="#ファイルの読み書きテスト">ファイルの読み書きテスト</a></h2>
<p><code>SUM</code>ビットをセットしたところで、ファイルの読み書きを試してみましょう。次のように<code>hello.txt</code>に書き込んでおいた文章が表示されたら成功です。</p>
<pre><code>$ ./run.sh

> readfile
Can you see me? Ah, there you are! You've unlocked the achievement "Virtio Newbie!"
</code></pre>
<p>ファイルの書き込みも試してみましょう。書き込みが成功すると、次のように書き込んだバイト数が表示されます。</p>
<pre><code>> writefile
wrote 2560 bytes to disk
</code></pre>
<p>QEMUを終了して、<code>disk.tar</code>を展開してみましょう。<code>disk.tar</code>を<code>virtio-blk</code>のディスクイメージとして指定しているので、ディスクへの書き込みがあり次第、QEMUがそのファイルを更新します。ファイルシステムとvirtio-blkを正しく実装できていれば、<code>writefile</code>システムコールで書き込んだ文章が表示されます。</p>
<pre><code>$ mkdir tmp
$ cd tmp
$ tar xf ../disk.tar
$ ls -alh
total 4.0K
drwxr-xr-x  4 seiya staff 128 Jul 22 22:50 .
drwxr-xr-x 25 seiya staff 800 Jul 22 22:49 ..
-rw-r--r--  1 seiya staff  26 Jan  1  1970 hello.txt
-rw-r--r--  1 seiya staff   0 Jan  1  1970 meow.txt
$ cat hello.txt
Hello from shell!
</code></pre>
<p>これでOSの基本機能である「ファイルシステム」を手に入れました！</p></main><footer class="mt-8 border-t border-gray-200 py-4"><div class="container mx-auto px-4 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 text-lg"><a href="/ja/17-conclusion">おわりに ⏩</a><a href="/ja/15-virtio-blk" class="sm:-order-1">⏪ ディスク読み書き</a></div></footer></body></html>