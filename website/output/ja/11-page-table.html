<!DOCTYPE html>
<html><head><title>ページテーブル - 1000行で作るOS</title><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" href="/styles.css"><meta name="generator" content="Docship (https://github.com/nuta/docship)"></head><body class="mx-auto max-w-3xl w-full py-8 px-4"><header><h1 class="text-center mb-8 text-xl font-bold">1000行で作るOS - ページテーブル</h1><div class="mb-8 container mx-auto flex justify-center"><ol class="w-full my-0 sm:w-fit grid grid-rows-[repeat(9,auto)] grid-flow-col gap-x-4" start="0"><li class="my-1"><a href="/ja/index" class="">はじめに</a></li><li class="my-1"><a href="/ja/01-setting-up-development-environment" class="">開発環境</a></li><li class="my-1"><a href="/ja/02-assembly" class="">RISC-V入門</a></li><li class="my-1"><a href="/ja/03-overview" class="">OSの全体像</a></li><li class="my-1"><a href="/ja/04-boot" class="">ブート</a></li><li class="my-1"><a href="/ja/05-hello-world" class="">Hello World!</a></li><li class="my-1"><a href="/ja/06-libc" class="">C標準ライブラリ</a></li><li class="my-1"><a href="/ja/07-kernel-panic" class="">カーネルパニック</a></li><li class="my-1"><a href="/ja/08-exception" class="">例外処理</a></li><li class="my-1"><a href="/ja/09-memory-allocation" class="">メモリ割り当て</a></li><li class="my-1"><a href="/ja/10-process" class="">プロセス</a></li><li class="my-1"><a href="/ja/11-page-table" class="font-bold">ページテーブル</a></li><li class="my-1"><a href="/ja/12-application" class="">アプリケーション</a></li><li class="my-1"><a href="/ja/13-user-mode" class="">ユーザーモード</a></li><li class="my-1"><a href="/ja/14-system-call" class="">システムコール</a></li><li class="my-1"><a href="/ja/15-virtio-blk" class="">ディスク読み書き</a></li><li class="my-1"><a href="/ja/16-file-system" class="">ファイルシステム</a></li><li class="my-1"><a href="/ja/17-conclusion" class="">おわりに</a></li></ol></div></header><main><p>プログラムがメモリにアクセスする際、CPUではある変換が行われます。仮想アドレスから物理アドレスへの変換です。仮想アドレスと物理アドレスの対応表のことを <strong>「ページテーブル」</strong> と呼びます。ページテーブルを切り替えることで同じ仮想アドレスでも異なる物理アドレスにアクセスさせることができます。プロセスごとのメモリ空間 (仮想アドレス空間) を隔離し、またカーネルとアプリケーションがそれぞれ利用する領域を分けることで、システムの安全性を高めることができます。</p>
<p>本章では、プロセスごとに独立したメモリ空間を実現するためにページテーブルの構築・切り替え処理を実装します。</p>
<h2 id="仮想アドレスの構造"><a class="anchor" href="#仮想アドレスの構造">仮想アドレスの構造</a></h2>
<p>本書では、RISC-Vのページング機構のうちSv32というモードを利用します。2段構造のページテーブルです。32ビットの仮想アドレスを、ページテーブル (1段目) のインデックス (<code>VPN[1]</code>)、2段目のインデックス (<code>VPN[0]</code>)、ページ内のオフセット (<code>offset</code>) に分割します。</p>
<p>これは説明されるより、実際にどのような値になるかを見た方が分かりやすいでしょう。</p>
<p>TODO:</p>
<blockquote class="callout callout-tip">
<p>よく観察すると、次のことに気づくと思います。</p>
<ul>
<li>真ん中あたりのビット (<code>VPN[0]</code>) をいじっても、1段目のインデックスは変化しない。つまり、近いアドレスのページテーブルエントリは、同じ2段目のページテーブルに集中している。</li>
<li>下位ビットをいじっても、<code>VPN[1]</code>と<code>VPN[0]</code>ともに変わらない。つまり、同じ4KBのページ内のアドレスは、同じページテーブルエントリを参照する。</li>
</ul>
</blockquote>
<p>このように、近いアドレスはページテーブル中の同じ部分を使うようになります。参照の局所性 (<a href="https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E3%81%AE%E5%B1%80%E6%89%80%E6%80%A7">Wikipedia</a>) というプログラムの特性を利用することで、ページテーブルのサイズを小さく抑えられること、またページテーブルエントリのキャッシュ (TLB: Translation Lookaside Buffer) が効果的であることが分かります。</p>
<p>CPUはメモリアクセスする際に、<code>VPN[1]</code>と<code>VPN[0]</code>で対応するページテーブルのエントリを特定し、そのエントリの物理アドレスと<code>offset</code>を足し合わせることで、最終的にアクセスする物理アドレスを計算します。</p>
<h2 id="ページテーブルの構築"><a class="anchor" href="#ページテーブルの構築">ページテーブルの構築</a></h2>
<p>ではSv32方式のページテーブルを構築してみましょう。まずは、いくつかのマクロを定義します。<code>SATP_SV32</code>は「Sv32モードでページングを有効化する」ことを示す<code>satp</code>レジスタのビット、<code>PAGE_*</code>はページテーブルエントリに設定するビットです。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">SATP_SV32</span> (<span class="pl-c1">1u</span> &#x3C;&#x3C; <span class="pl-c1">31</span>)
#<span class="pl-k">define</span> <span class="pl-en">PAGE_V</span>    (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">0</span>)   <span class="pl-c">// 有効化ビット</span>
#<span class="pl-k">define</span> <span class="pl-en">PAGE_R</span>    (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">1</span>)   <span class="pl-c">// 読み込み可能</span>
#<span class="pl-k">define</span> <span class="pl-en">PAGE_W</span>    (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">2</span>)   <span class="pl-c">// 書き込み可能</span>
#<span class="pl-k">define</span> <span class="pl-en">PAGE_X</span>    (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">3</span>)   <span class="pl-c">// 実行可能</span>
#<span class="pl-k">define</span> <span class="pl-en">PAGE_U</span>    (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">4</span>)   <span class="pl-c">// ユーザーモードでアクセス可能</span>
</code></pre>
<p>次の<code>map_page</code>関数は、1段目のページテーブル (<code>table1</code>)、マップしたい仮想アドレス (<code>vaddr</code>)、マップ先の物理アドレス (<code>paddr</code>)、ページテーブルエントリに設定するフラグ (<code>flags</code>) を受け取り、ページテーブルを構築します。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">map_page</span>(<span class="pl-c1">uint32_t</span> *table1, <span class="pl-c1">uint32_t</span> vaddr, <span class="pl-c1">paddr_t</span> paddr, <span class="pl-c1">uint32_t</span> flags) {
    <span class="pl-k">if</span> (!<span class="pl-c1">is_aligned</span>(vaddr, PAGE_SIZE))
        <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>unaligned vaddr <span class="pl-c1">%x</span><span class="pl-pds">"</span></span>, vaddr);

    <span class="pl-k">if</span> (!<span class="pl-c1">is_aligned</span>(paddr, PAGE_SIZE))
        <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>unaligned paddr <span class="pl-c1">%x</span><span class="pl-pds">"</span></span>, paddr);

    <span class="pl-c1">uint32_t</span> vpn1 = (vaddr >> <span class="pl-c1">22</span>) &#x26; <span class="pl-c1">0x3ff</span>;
    <span class="pl-k">if</span> ((table1[vpn1] &#x26; PAGE_V) == <span class="pl-c1">0</span>) {
        <span class="pl-c">// 2段目のページテーブルが存在しないので作成する</span>
        <span class="pl-c1">uint32_t</span> pt_paddr = <span class="pl-c1">alloc_pages</span>(<span class="pl-c1">1</span>);
        table1[vpn1] = ((pt_paddr / PAGE_SIZE) &#x3C;&#x3C; <span class="pl-c1">10</span>) | PAGE_V;
    }

    <span class="pl-c">// 2段目のページテーブルにエントリを追加する</span>
    <span class="pl-c1">uint32_t</span> vpn0 = (vaddr >> <span class="pl-c1">12</span>) &#x26; <span class="pl-c1">0x3ff</span>;
    <span class="pl-c1">uint32_t</span> *table0 = (<span class="pl-c1">uint32_t</span> *) ((table1[vpn1] >> <span class="pl-c1">10</span>) * PAGE_SIZE);
    table0[vpn0] = ((paddr / PAGE_SIZE) &#x3C;&#x3C; <span class="pl-c1">10</span>) | flags | PAGE_V;
}
</code></pre>
<p>2段目のページテーブルを用意して、2段目の設定したいページテーブルエントリへマップ先の物理ページ番号とフラグを設定するだけです。</p>
<p><code>paddr / PAGE_SIZE</code>と<code>PAGE_SIZE</code>で割っているのは、エントリに設定するのは物理アドレスではなく物理ページ番号だからです。</p>
<h2 id="カーネルページのマッピング"><a class="anchor" href="#カーネルページのマッピング">カーネルページのマッピング</a></h2>
<p>ページテーブルにはアプリケーション (ユーザー空間) のマッピングだけでなく、カーネルのそれも設定する必要があります。</p>
<p>本書では、カーネルのマッピングは、カーネルの仮想アドレスと物理アドレスが一致するように設定します。こうすることで、ページングを有効化しても同じコードを引き続き実行できるようになります。</p>
<p>まずはカーネルのリンカスクリプトの修正です。カーネルが利用するアドレスの先頭 (<code>__kernel_base</code>) を定義します。</p>
<pre><div class="code-block-title">kernel.ld</div><code class="language-plain">ENTRY(boot)

SECTIONS {
    . = 0x80200000;
    __kernel_base = .;
</code></pre>
<blockquote class="callout callout-warning">
<p><code>. = 0x80200000</code>の<strong>後ろ</strong>に定義するよう注意してください。順番が逆だと、<code>__kernel_base</code>の値がゼロになります。</p>
</blockquote>
<p>次にプロセス管理構造体にページテーブルを追加します。1段目のページテーブルを指すポインタです。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c"><span class="pl-k">struct</span> process {
    <span class="pl-k">int</span> pid;
    <span class="pl-k">int</span> state;
    <span class="pl-c1">vaddr_t</span> sp;
    <span class="pl-c1">uint32_t</span> *page_table;
    <span class="pl-c1">uint8_t</span> stack[<span class="pl-c1">8192</span>];
};
</code></pre>
<p>最後に、<code>create_process</code>関数でカーネルのページをマッピングします。カーネルのページは、<code>__kernel_base</code>から<code>__free_ram_end</code>までの範囲です。こうすることで、静的に配置される領域 (<code>.text</code>など) と、<code>alloc_pages</code>関数で動的に割り当てられる領域の両方を、カーネルはいつでもアクセスできるようにしておきます。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">extern</span> <span class="pl-k">char</span> __kernel_base[];

<span class="pl-k">struct</span> process *<span class="pl-en">create_process</span>(<span class="pl-c1">uint32_t</span> pc) {
    <span class="pl-c">/* 省略 */</span>

    <span class="pl-c1">uint32_t</span> *page_table = (<span class="pl-c1">uint32_t</span> *) <span class="pl-c1">alloc_pages</span>(<span class="pl-c1">1</span>);

    <span class="pl-c">// カーネルのページをマッピングする</span>
    <span class="pl-k">for</span> (<span class="pl-c1">paddr_t</span> paddr = (<span class="pl-c1">paddr_t</span>) __kernel_base;
         paddr &#x3C; (<span class="pl-c1">paddr_t</span>) __free_ram_end; paddr += PAGE_SIZE)
        <span class="pl-c1">map_page</span>(page_table, paddr, paddr, PAGE_R | PAGE_W | PAGE_X);

    proc-><span class="pl-smi">pid</span> = i + <span class="pl-c1">1</span>;
    proc-><span class="pl-smi">state</span> = PROC_RUNNABLE;
    proc-><span class="pl-smi">sp</span> = (<span class="pl-c1">uint32_t</span>) sp;
    proc-><span class="pl-smi">page_table</span> = page_table;
    <span class="pl-k">return</span> proc;
}
</code></pre>
<h2 id="ページテーブルの切り替え"><a class="anchor" href="#ページテーブルの切り替え">ページテーブルの切り替え</a></h2>
<p>最後に、プロセスの切り替え時にページテーブルを切り替えるようにします。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">yield</span>(<span class="pl-k">void</span>) {
    <span class="pl-c">/* 省略 */</span>

    <span class="pl-k">__asm__</span> <span class="pl-smi">__volatile__</span>(
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw satp, %[satp]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw sscratch, %[sscratch]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        :
        <span class="pl-c">// 行末のカンマを忘れずに！</span>
        : [satp] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (SATP_SV32 | ((<span class="pl-c1">uint32_t</span>) next-><span class="pl-smi">page_table</span> / PAGE_SIZE)),
          [sscratch] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> ((<span class="pl-c1">uint32_t</span>) &#x26;next-><span class="pl-smi">stack</span>[<span class="pl-k">sizeof</span>(next-><span class="pl-smi">stack</span>)])
    );

    <span class="pl-c1">switch_context</span>(&#x26;prev-><span class="pl-smi">sp</span>, &#x26;next-><span class="pl-smi">sp</span>);
}
</code></pre>
<p><code>satp</code>レジスタへの一段目のページテーブルを設定することで、ページテーブルを切り替えることができます。なお、物理ページ番号を指定するので、<code>PAGE_SIZE</code>で割っています。</p>
<p>ページテーブルの設定の前後に追加されている <code>sfence.vma</code> 命令は、「ページテーブルへの変更をきちんと完了させることを保証する (参考: メモリフェンス)」「ページテーブルエントリのキャッシュ (TLB) を消す」という意味合いがあります。</p>
<blockquote class="callout callout-tip">
<p>ブート時には、ページングが無効化されています (<code>satp</code>レジスタが設定されていない)。そのため、仮想アドレスと物理アドレスが一致しているかような挙動になります。</p>
</blockquote>
<h2 id="ページングのテスト"><a class="anchor" href="#ページングのテスト">ページングのテスト</a></h2>
<p>ページングを一通り実装したところで、実際に動かしてみましょう。</p>
<pre><code class="language-plain">$ ./run.sh

starting process A
Astarting process B
BABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB
</code></pre>
<p>表示内容は前章と全く同じです。ページングを有効化しても変化はありません。そこで、ページテーブルを上手く設定できているかをQEMUモニタを使って見てみましょう。</p>
<h2 id="ページテーブルの内容を確認する"><a class="anchor" href="#ページテーブルの内容を確認する">ページテーブルの内容を確認する</a></h2>
<p>仮想アドレス<code>0x80000000</code>周辺が、どうマップされているかを見てみましょう。正しく設定されていれば、<code>(仮想アドレス) == (物理アドレス)</code>になるようにマップされているはずです。</p>
<pre><code class="language-plain">QEMU 8.0.2 monitor - type 'help' for more information
(qemu) stop
(qemu) info registers
 ...
 satp     80080253
 ...
</code></pre>
<p>まず、<code>satp</code>レジスタの値を見てみると<code>0x80080253</code>になっています。これを仕様書の通り解釈すると <code>0x80080253 &#x26; 0x3fffff) * 4096 = 0x80253000</code> がページテーブルの一段目の先頭物理アドレスです。</p>
<p>では、ページテーブルの中身を見てみましょう。QEMUにはメモリの内容 (メモリダンプ) を表示するコマンドを用意しています。<code>xp</code>コマンドを使うと指定した物理アドレスのメモリダンプを表示できます。<code>/x</code>は16進数で表示することを意味します。<code>/1024x</code>のように<code>x</code>の前に数字を書くと、その分表示してくれます。</p>
<blockquote class="callout callout-tip">
<p><code>xp</code>ではなく<code>x</code>コマンドを使うと、指定した<strong>仮想</strong>アドレスのメモリダンプを確認できます。後に設定するユーザー空間 (アプリケーション) では、カーネル空間とは違い仮想アドレスと物理アドレスが同一にならないため、ユーザー空間のメモリ内容を調べたいときに便利です。</p>
</blockquote>
<p>ここでは仮想アドレス<code>0x80000000</code>に紐づく2段目のページテーブルが知りたいので、<code>0x80000000 >> 22 = 512</code>番目のエントリを見てみます。1エントリ4バイトなので、4をかけています。</p>
<pre><code class="language-plain">(qemu) xp /x 0x80253000+512*4
0000000080253800: 0x20095001
</code></pre>
<p>1列目が物理アドレス、2列目以降がメモリの値です。ゼロではないので、なんらかの値が設定されていることがわかります。これを仕様書の通り解釈すると、<code>(0x20095000 >> 10) * 4096 = 0x80254000</code> に2段目のページテーブルがあることがわかります。2段目のテーブル全体 (1024エントリ) をみてみましょう。</p>
<pre><code>(qemu) xp /1024x 0x80254000
0000000080254000: 0x00000000 0x00000000 0x00000000 0x00000000
0000000080254010: 0x00000000 0x00000000 0x00000000 0x00000000
0000000080254020: 0x00000000 0x00000000 0x00000000 0x00000000
0000000080254030: 0x00000000 0x00000000 0x00000000 0x00000000
...
00000000802547f0: 0x00000000 0x00000000 0x00000000 0x00000000
0000000080254800: 0x2008004f 0x2008040f 0x2008080f 0x20080c0f
0000000080254810: 0x2008100f 0x2008140f 0x2008180f 0x20081c0f
0000000080254820: 0x2008200f 0x2008240f 0x2008280f 0x20082c0f
0000000080254830: 0x2008300f 0x2008340f 0x2008380f 0x20083c0f
0000000080254840: 0x200840cf 0x2008440f 0x2008484f 0x20084c0f
0000000080254850: 0x200850cf 0x2008540f 0x200858cf 0x20085c0f
0000000080254860: 0x2008600f 0x2008640f 0x2008680f 0x20086c0f
0000000080254870: 0x2008700f 0x2008740f 0x2008780f 0x20087c0f
0000000080254880: 0x200880cf 0x2008840f 0x2008880f 0x20088c0f
...
</code></pre>
<p>最初の方はゼロで埋まっていますが、<code>(0x800バイト目) / 4 = 512エントリ目</code>から値が埋まっています。<code>512 &#x3C;&#x3C; 12 = 0x200000</code>であるため、2段目は<code>0x200000</code>バイト目の部分からマップされていることがわかります。</p>
<p>ここまでメモリダンプを自力で読んでみましたが、QEMUには使用中のページテーブルの設定情報を読みやすい形で表示するコマンドがあります。正しくマップされているかを最終確認したい場合は<code>info mem</code>コマンドを使うとよいでしょう。</p>
<pre><code class="language-plain">(qemu) info mem
vaddr    paddr            size     attr
-------- ---------------- -------- -------
80200000 0000000080200000 00001000 rwx--a-
80201000 0000000080201000 0000f000 rwx----
80210000 0000000080210000 00001000 rwx--ad
80211000 0000000080211000 00001000 rwx----
80212000 0000000080212000 00001000 rwx--a-
80213000 0000000080213000 00001000 rwx----
80214000 0000000080214000 00001000 rwx--ad
80215000 0000000080215000 00001000 rwx----
80216000 0000000080216000 00001000 rwx--ad
80217000 0000000080217000 00009000 rwx----
80220000 0000000080220000 00001000 rwx--ad
80221000 0000000080221000 0001f000 rwx----
80240000 0000000080240000 00001000 rwx--ad
80241000 0000000080241000 001bf000 rwx----
80400000 0000000080400000 00400000 rwx----
80800000 0000000080800000 00400000 rwx----
80c00000 0000000080c00000 00400000 rwx----
81000000 0000000081000000 00400000 rwx----
81400000 0000000081400000 00400000 rwx----
81800000 0000000081800000 00400000 rwx----
81c00000 0000000081c00000 00400000 rwx----
82000000 0000000082000000 00400000 rwx----
82400000 0000000082400000 00400000 rwx----
82800000 0000000082800000 00400000 rwx----
82c00000 0000000082c00000 00400000 rwx----
83000000 0000000083000000 00400000 rwx----
83400000 0000000083400000 00400000 rwx----
83800000 0000000083800000 00400000 rwx----
83c00000 0000000083c00000 00400000 rwx----
84000000 0000000084000000 00241000 rwx----
</code></pre>
<p>1列目から順に、仮想アドレス、物理アドレス (マップ先)、サイズ (16進バイト数)、属性を表しています。属性は<code>r</code>が読み込み可能、<code>w</code>が書き込み可能、<code>x</code>が実行可能を表します。また、<code>a</code>と<code>d</code>は、それぞれCPUが「ページにアクセスしたことがある」、「ページに書き込みしたことがある」ことを表しています。実際に使われているページをOSが把握するための補助的な情報です。</p>
<blockquote class="callout callout-tip">
<p>ページテーブルの設定ミスは、初学者にとってはデバッグがかなり難しい部分です。もし上手く動かない場合は、「付録: ページングのデバッグ」を参照してください。</p>
</blockquote>
<h2 id="ページングのデバッグ-おまけ"><a class="anchor" href="#ページングのデバッグ-おまけ">ページングのデバッグ (おまけ)</a></h2>
<p>ページテーブルの設定は難易度が少し高く、ミスに気づきにくいものです。そこで、本章ではよくあるページングのミスを題材に、どうデバッグできるかを見ていきます。</p>
<h3 id="モードの設定し忘れ"><a class="anchor" href="#モードの設定し忘れ">モードの設定し忘れ</a></h3>
<p>まずは<code>satp</code>レジスタにモードを設定し忘れた場合です。次のように抜いてみましょう。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c">    <span class="pl-k">__asm__</span> <span class="pl-en">__volatile__</span>(
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw satp, %[satp]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        :
        : [satp] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (((<span class="pl-c1">uint32_t</span>) next->page_table / PAGE_SIZE)) <span class="pl-c">// SATP_SV32を忘れた</span>
    );
</code></pre>
<p>実際に動かしてみると、きちんと動作しているように見えるはずです。これは、ページテーブルの場所が指定されてはいますがページングが無効化されているままだからです。この場合、QEMUモニタの<code>info mem</code>コマンドで確認すると、次のように表示されます。</p>
<pre><code>(qemu) info mem
No translation or protection
</code></pre>
<h3 id="物理ページ番号ではなく物理アドレスを指定している"><a class="anchor" href="#物理ページ番号ではなく物理アドレスを指定している">物理ページ番号ではなく物理アドレスを指定している</a></h3>
<p>次に物理ページ番号ではなく物理アドレスでページテーブルを指定してしまった時です。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c">    <span class="pl-k">__asm__</span> <span class="pl-en">__volatile__</span>(
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw satp, %[satp]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>sfence.vma<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        :
        : [satp] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (SATP_SV32 | ((<span class="pl-c1">uint32_t</span>) next->page_table)) <span class="pl-c">// シフトし忘れ</span>
    );
</code></pre>
<p>OSを起動して<code>info mem</code>コマンドで確認すると、次のように空っぽになっているはずです。</p>
<pre><code class="language-plain">$ ./run.sh

QEMU 8.0.2 monitor - type 'help' for more information
(qemu) stop
(qemu) info mem
vaddr    paddr            size     attr
-------- ---------------- -------- -------
</code></pre>
<p>レジスタダンプを見て、CPUが何をしているのかを確認しましょう。</p>
<pre><code class="language-plain">(qemu) info registers

CPU#0
 V      =   0
 pc       80200188
 ...
 scause   0000000c
 ...
</code></pre>
<p><code>80200188</code>を<code>llvm-addr2line</code>で確認すると例外ハンドラの先頭アドレス、例外の発生理由 (<code>scause</code>レジスタ) は仕様書によると「Instruction page fault」に該当します。ページテーブルを切り替えて次の命令を実行するとき、CPUはページテーブルからプログラムカウンタの仮想アドレスを物理アドレスに変換しようとします。しかし、ページテーブルのアドレス (<code>satp</code>レジスタ) が正しくないため、変換に失敗し、ページフォルトが発生しています。</p>
<p>より具体的に何が起きているのかをQEMUのログから見てみましょう。</p>
<pre><div class="code-block-title">run.sh</div><code class="language-bash"><span class="pl-smi">$QEMU</span> -machine virt -bios default -nographic -serial mon:stdio --no-reboot \
    -d unimp,guest_errors,int,cpu_reset -D qemu.log \
    -kernel kernel.elf
</code></pre>
<pre><code class="language-plain">Invalid read at addr 0x253000800, size 4, region '(null)', reason: rejected
riscv_cpu_do_interrupt: hart:0, async:0, cause:0000000c, epc:0x80200580, tval:0x80200580, desc=exec_page_fault
Invalid read at addr 0x253000800, size 4, region '(null)', reason: rejected
riscv_cpu_do_interrupt: hart:0, async:0, cause:0000000c, epc:0x80200188, tval:0x80200188, desc=exec_page_fault
Invalid read at addr 0x253000800, size 4, region '(null)', reason: rejected
riscv_cpu_do_interrupt: hart:0, async:0, cause:0000000c, epc:0x80200188, tval:0x80200188, desc=exec_page_fault
</code></pre>
<ul>
<li>最初のページフォルトの例外発生箇所 (<code>epc</code>レジスタ) の値は<code>0x80200580</code>で、<code>llvm-objdump</code>で確認すると<code>satp</code>レジスタを設定した直後の命令を指している。つまり、ページングを有効化した直後にページフォルトが発生している。</li>
<li>2番目以降のページフォルトはみな同じ値が続いていく。例外発生箇所は<code>0x80200188</code>で、<code>llvm-objdump</code>で確認すると例外ハンドラの先頭アドレスを指している。このログが無限に続いていくことから、例外ハンドラを実行しようとして再度例外 (ページフォルト) が発生していることがわかる。</li>
<li><code>info registers</code>コマンドを見ると、<code>satp</code>レジスタの値は<code>0x80253000</code>で、仕様書に従って物理アドレスを計算すると <code>(0x80253000 &#x26; 0x3fffff) * 4096 = 0x253000000</code> で、これは32ビットのアドレス空間に収まらない。このことから、異常な値が入っていることがわかる。</li>
</ul>
<p>このように、QEMUのログとレジスタダンプ、メモリダンプを確認していきながら、どこがおかしいのかを探していくことができます。ただし、デバッグで最も大事なことは「仕様書をしっかり読む」ことです。「仕様書の記述を見落としていた・勘違いしていた」ということが大変よくあります。</p></main><footer class="mt-8 border-t border-gray-200 py-4"><div class="container mx-auto px-4 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 text-lg"><a href="/ja/12-application">アプリケーション ⏩</a><a href="/ja/10-process" class="sm:-order-1">⏪ プロセス</a></div></footer></body></html>