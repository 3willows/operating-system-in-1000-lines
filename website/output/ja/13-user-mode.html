<!DOCTYPE html>
<html><head><title>ユーザーモード - <undefined></undefined></title><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" href="/styles.css"><meta name="generator" content="Docship (https://github.com/nuta/docship)"></head><body class="mx-auto max-w-3xl w-full py-8 px-4"><header><h1 class="text-center mb-8 text-xl font-bold"><undefined></undefined> - ユーザーモード</h1><div class="mb-8 container mx-auto flex justify-center"><ol class="w-full my-0 sm:w-fit grid grid-rows-[repeat(9,auto)] grid-flow-col gap-x-4" start="0"><li class="my-1"><a href="/ja/index" class="">はじめに</a></li><li class="my-1"><a href="/ja/01-setting-up-development-environment" class="">開発環境</a></li><li class="my-1"><a href="/ja/02-assembly" class="">RISC-V入門</a></li><li class="my-1"><a href="/ja/03-overview" class="">OSの全体像</a></li><li class="my-1"><a href="/ja/04-boot" class="">ブート</a></li><li class="my-1"><a href="/ja/05-hello-world" class="">Hello World!</a></li><li class="my-1"><a href="/ja/06-libc" class="">C標準ライブラリ</a></li><li class="my-1"><a href="/ja/07-kernel-panic" class="">カーネルパニック</a></li><li class="my-1"><a href="/ja/08-exception" class="">例外処理</a></li><li class="my-1"><a href="/ja/09-memory-allocation" class="">メモリ割り当て</a></li><li class="my-1"><a href="/ja/10-process" class="">プロセス</a></li><li class="my-1"><a href="/ja/11-page-table" class="">ページテーブル</a></li><li class="my-1"><a href="/ja/12-application" class="">アプリケーション</a></li><li class="my-1"><a href="/ja/13-user-mode" class="font-bold">ユーザーモード</a></li><li class="my-1"><a href="/ja/14-system-call" class="">システムコール</a></li><li class="my-1"><a href="/ja/15-virtio-blk" class="">ディスク読み書き</a></li><li class="my-1"><a href="/ja/16-file-system" class="">ファイルシステム</a></li><li class="my-1"><a href="/ja/17-conclusion" class="">おわりに</a></li></ol></div></header><main><p>本章では、前章で作ったアプリケーションの実行イメージを動かしてみます。</p>
<h2 id="実行ファイルの展開"><a class="anchor" href="#実行ファイルの展開">実行ファイルの展開</a></h2>
<p>まずは実行イメージの展開に必要な定義をいくつかしましょう。まずは、実行イメージの基点アドレス (<code>USER_BASE</code>) です。これは、<code>user.ld</code>で定義されている開始アドレスと合致する必要があります。</p>
<p>ELF形式のような一般的な実行可能ファイルであれば、そのファイルのヘッダ (ELFの場合プログラムヘッダ) にロード先のアドレスが書かれています。しかし、本書のアプリケーションの実行イメージは生バイナリなので、このように決め打ちで用意しておく必要があります。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">USER_BASE</span> <span class="pl-c1">0x1000000</span>
</code></pre>
<p>次に、<code>shell.bin.o</code>に入っている実行イメージへのポインタとイメージサイズのシンボルを定義しておきます。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">extern</span> <span class="pl-k">char</span> _binary_shell_bin_start[], _binary_shell_bin_size[];
</code></pre>
<p>次に、実行イメージをプロセスのアドレス空間にマップする処理を<code>create_process</code>関数に追加します。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">user_entry</span>(<span class="pl-k">void</span>) {
    <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>not yet implemented<span class="pl-pds">"</span></span>); <span class="pl-c">// 後で実装する</span>
}

<span class="pl-k">struct</span> process *<span class="pl-en">create_process</span>(<span class="pl-k">const</span> <span class="pl-k">void</span> *image, <span class="pl-c1">size_t</span> image_size) {
    <span class="pl-c">/* 省略 */</span>
    *--sp = <span class="pl-c1">0</span>;                      <span class="pl-c">// s3</span>
    *--sp = <span class="pl-c1">0</span>;                      <span class="pl-c">// s2</span>
    *--sp = <span class="pl-c1">0</span>;                      <span class="pl-c">// s1</span>
    *--sp = <span class="pl-c1">0</span>;                      <span class="pl-c">// s0</span>
    *--sp = (<span class="pl-c1">uint32_t</span>) user_entry;  <span class="pl-c">// ra</span>

    <span class="pl-c1">uint32_t</span> *page_table = (<span class="pl-c1">uint32_t</span> *) <span class="pl-c1">alloc_pages</span>(<span class="pl-c1">1</span>);

    <span class="pl-c">// カーネルのページをマッピングする</span>
    <span class="pl-k">for</span> (<span class="pl-c1">paddr_t</span> paddr = (<span class="pl-c1">paddr_t</span>) __kernel_base;
         paddr &#x3C; (<span class="pl-c1">paddr_t</span>) __free_ram_end; paddr += PAGE_SIZE)
        <span class="pl-c1">map_page</span>(page_table, paddr, paddr, PAGE_R | PAGE_W | PAGE_X);

    <span class="pl-c">// ユーザーのページをマッピングする</span>
    <span class="pl-k">for</span> (<span class="pl-c1">uint32_t</span> off = <span class="pl-c1">0</span>; off &#x3C; image_size; off += PAGE_SIZE) {
        <span class="pl-c1">paddr_t</span> page = <span class="pl-c1">alloc_pages</span>(<span class="pl-c1">1</span>);
        <span class="pl-c1">memcpy</span>((<span class="pl-k">void</span> *) page, image + off, PAGE_SIZE);
        <span class="pl-c1">map_page</span>(page_table, USER_BASE + off, page,
                 PAGE_U | PAGE_R | PAGE_W | PAGE_X);
    }
</code></pre>
<p><code>create_process</code>関数は、実行イメージへのポインタ (<code>image</code>) とイメージサイズ (<code>image_size</code>) を引数に取るように変更しました。指定されたサイズ分、実行イメージをページ単位でコピーして、ユーザーモードのページにマッピングしています。また、初回のコンテキストスイッチ時のジャンプ先を<code>user_entry</code>に設定しています。今のところは空っぽの関数にしておきます。</p>
<blockquote class="callout callout-warning">
<p>このとき、実行イメージをコピーせずにそのままマッピングしてしまうと、同じアプリケーションのプロセスたちが同じ物理ページを共有することになります。</p>
</blockquote>
<p>最後に <code>create_process</code> 関数の呼び出し側の修正と、ユーザープロセスを作成するようにします。</p>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">kernel_main</span>(<span class="pl-k">void</span>) {
    <span class="pl-c1">memset</span>(__bss, <span class="pl-c1">0</span>, (<span class="pl-c1">size_t</span>) __bss_end - (<span class="pl-c1">size_t</span>) __bss);

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n\n</span><span class="pl-pds">"</span></span>);

    <span class="pl-c1">WRITE_CSR</span>(stvec, (<span class="pl-c1">uint32_t</span>) kernel_entry);

    idle_proc = <span class="pl-c1">create_process</span>(<span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
    idle_proc-><span class="pl-smi">pid</span> = -<span class="pl-c1">1</span>; <span class="pl-c">// idle</span>
    current_proc = idle_proc;

    <span class="pl-c1">create_process</span>(_binary_shell_bin_start, (<span class="pl-c1">size_t</span>) _binary_shell_bin_size);

    <span class="pl-c1">yield</span>();
    <span class="pl-c1">PANIC</span>(<span class="pl-s"><span class="pl-pds">"</span>switched to idle process<span class="pl-pds">"</span></span>);
}
</code></pre>
<p>実際に動かしてみて、実行イメージが期待通りマッピングされているかQEMUモニタで確認してみましょう。</p>
<blockquote class="callout callout-tip">
<p>まだこの時点ではユーザーモードへの移行処理がないので、アプリケーションは動きません。まずは、実行イメージが正しく展開されているかのみを確認します。</p>
</blockquote>
<pre><code class="language-plain">(qemu) info mem
vaddr    paddr            size     attr
-------- ---------------- -------- -------
01000000 0000000080265000 00001000 rwxu---
01001000 0000000080267000 00010000 rwxu---
</code></pre>
<p>仮想アドレス <code>0x1000000</code> (<code>USER_BASE</code>) に、物理アドレス <code>0x80265000</code> がマップされていることがわかります。この物理アドレスの中身を見てみましょう。物理メモリの内容を表示するには、<code>xp</code>コマンドを使います。</p>
<pre><code class="language-plain">(qemu) xp /32b 0x80265000
0000000080265000: 0x37 0x05 0x01 0x01 0x13 0x05 0x05 0x26
0000000080265008: 0x2a 0x81 0x19 0x20 0x29 0x20 0x00 0x00
0000000080265010: 0x01 0xa0 0x00 0x00 0x82 0x80 0x01 0xa0
0000000080265018: 0x09 0xca 0xaa 0x86 0x7d 0x16 0x13 0x87
</code></pre>
<p>何かしらデータが入っているようです。<code>shell.bin</code>の中身を確認してみると、確かに合致しています。</p>
<pre><code class="language-plain">$ hexdump -C shell.bin | head
00000000  37 05 01 01 13 05 05 26  2a 81 19 20 29 20 00 00  |7......&#x26;*.. ) ..|
00000010  01 a0 00 00 82 80 01 a0  09 ca aa 86 7d 16 13 87  |............}...|
00000020  16 00 23 80 b6 00 ba 86  75 fa 82 80 01 ce aa 86  |..#.....u.......|
00000030  03 87 05 00 7d 16 85 05  93 87 16 00 23 80 e6 00  |....}.......#...|
00000040  be 86 7d f6 82 80 03 c6  05 00 aa 86 01 ce 85 05  |..}.............|
00000050  2a 87 23 00 c7 00 03 c6  05 00 93 06 17 00 85 05  |*.#.............|
00000060  36 87 65 fa 23 80 06 00  82 80 03 46 05 00 15 c2  |6.e.#......F....|
00000070  05 05 83 c6 05 00 33 37  d0 00 93 77 f6 0f bd 8e  |......37...w....|
00000080  93 b6 16 00 f9 8e 91 c6  03 46 05 00 85 05 05 05  |.........F......|
00000090  6d f2 03 c5 05 00 93 75  f6 0f 33 85 a5 40 82 80  |m......u..3..@..|
</code></pre>
<p>16進数だと分かりづらいので、<code>xp</code>コマンドを使ってメモリ上の機械語を逆アセンブルしてみましょう。</p>
<pre><code class="language-plain">(qemu) xp /8i 0x80265000
0x80265000:  01010537          lui                     a0,16842752
0x80265004:  26050513          addi                    a0,a0,608
0x80265008:  812a              mv                      sp,a0
0x8026500a:  2019              jal                     ra,6                    # 0x80265010
0x8026500c:  2029              jal                     ra,10                   # 0x80265016
0x8026500e:  0000              illegal
0x80265010:  a001              j                       0                       # 0x80265010
0x80265012:  0000              illegal
</code></pre>
<p>何か計算した結果をスタックポインタに設定し、2回関数を呼び出しています。<code>shell.elf</code>の逆アセンブル結果と比較してみると、確かに合致しています。上手く展開できているようです。</p>
<pre><code class="language-plain">$ llvm-objdump -d shell.elf | head -n20

shell.elf:      file format elf32-littleriscv

Disassembly of section .text:

01000000 &#x3C;start>:
 1000000: 37 05 01 01   lui     a0, 4112
 1000004: 13 05 05 26   addi    a0, a0, 608
 1000008: 2a 81         mv      sp, a0
 100000a: 19 20         jal     0x1000010 &#x3C;main>
 100000c: 29 20         jal     0x1000016 &#x3C;exit>
 100000e: 00 00         unimp

01000010 &#x3C;main>:
 1000010: 01 a0         j       0x1000010 &#x3C;main>
 1000012: 00 00         unimp
</code></pre>
<h2 id="ユーザーモードへの移行"><a class="anchor" href="#ユーザーモードへの移行">ユーザーモードへの移行</a></h2>
<p>実行イメージを展開できたので、最後の処理を実装しましょう。それは「CPUの動作モードの切り替え」です。カーネルはS-Modeと呼ばれる特権モードで動作していますが、ユーザープログラムはU-Modeと呼ばれる非特権モードで動作します。以下がその実装です。</p>
<pre><div class="code-block-title">kernel.h</div><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">SSTATUS_SPIE</span> (<span class="pl-c1">1</span> &#x3C;&#x3C; <span class="pl-c1">5</span>)
</code></pre>
<pre><div class="code-block-title">kernel.c</div><code class="language-c"><span class="pl-c">// ↓ __attribute__((naked)) が追加されていることに注意</span>
<span class="pl-en">__attribute__</span>((naked)) void user_entry(<span class="pl-k">void</span>) {
    <span class="pl-k">__asm__</span> <span class="pl-smi">__volatile__</span>(
        <span class="pl-s"><span class="pl-pds">"</span>csrw sepc, %[sepc]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>csrw sstatus, %[sstatus]<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        <span class="pl-s"><span class="pl-pds">"</span>sret<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        :
        : [sepc] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (USER_BASE),
          [sstatus] <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span> (SSTATUS_SPIE)
    );
}
</code></pre>
<p>S-ModeからU-Modeへの切り替えは、<code>sret</code>命令で行います。ただし、動作モードを切り替える前に2つ下準備をしています。</p>
<ul>
<li><code>sepc</code>レジスタにU-Modeに移行した際のプログラムカウンタを設定する。</li>
<li><code>sstatus</code>レジスタの<code>SPIE</code>ビットを立てる。これを設定しておくと、U-Modeに入った際に割り込みが有効化され、例外と同じように<code>stvec</code>レジスタに設定しているハンドラが呼ばれるようになる。</li>
</ul>
<blockquote class="callout callout-tip">
<p>本書では割り込みを使わず代わりにポーリングを使うので、<code>SPIE</code>ビットを立てる必要はありません。しかし、有効化していても損はないので立てておきます。黙って割り込みを無視されるよりは分かりやすくて良いでしょう。</p>
</blockquote>
<h2 id="動作テスト"><a class="anchor" href="#動作テスト">動作テスト</a></h2>
<p>では実際に動かしてみてみましょう。といっても、<code>shell.c</code>は無限ループするだけなので画面上では上手く動いているのか分かりません。代わりにQEMUモニタで覗いてみましょう。</p>
<pre><code class="language-plain">(qemu) info registers

CPU#0
 V      =   0
 pc       01000010
</code></pre>
<p>レジスタダンプを見てみると、<code>0x1000010</code>をずっと実行しているようです。上手く動いている気がしますが、なんだか納得がいきません。そこで、U-Mode特有の挙動が現れるかを見てみましょう。<code>shell.c</code>に一行追加してみます。</p>
<pre><div class="code-block-title">shell.c</div><code class="language-c">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>user.h<span class="pl-pds">"</span></span>

<span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {
    *((<span class="pl-k">volatile</span> <span class="pl-k">int</span> *) <span class="pl-c1">0x80200000</span>) = <span class="pl-c1">0x1234</span>;
    <span class="pl-k">for</span> (;;);
}
</code></pre>
<p>この<code>0x80200000</code>は、ページテーブル上でマップされているカーネルが利用するメモリ領域です。しかし、ページテーブルエントリの<code>U</code>ビットが立っていない「カーネル用ページ」であるため、例外 (ページフォルト) が発生するはずです。</p>
<p>実行してみると、期待通り例外が発生しました。</p>
<pre><code class="language-plain">$ ./run.sh

PANIC: kernel.c:71: unexpected trap scause=0000000f, stval=80200000, sepc=0100001a
</code></pre>
<p><code>0xf = 15</code>番目の例外を仕様書で確認してみると「Store/AMO page fault」に対応します。期待通りの例外が発生しているようです。また、<code>sepc</code>レジスタの例外発生時のプログラムカウンタを見てみると、確かに<code>shell.c</code>に追加している行を指しています。</p>
<pre><code class="language-plain">$ llvm-addr2line -e shell.elf 0x100001a
/Users/seiya/dev/os-from-scratch/shell.c:4
</code></pre>
<p>初めてのアプリケーションを実行できました！</p></main><footer class="mt-8 border-t border-gray-200 py-4"><div class="container mx-auto px-4 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 text-lg"><a href="/ja/14-system-call">システムコール ⏩</a><a href="/ja/12-application" class="sm:-order-1">⏪ アプリケーション</a></div></footer></body></html>